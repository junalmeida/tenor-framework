using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Runtime.InteropServices;
namespace Tenor.Security
{
    /// <summary>
    /// This class implements captcha algorithms. A Captcha is a type of challenge-response test used in computing to ensure that the response is not generated by a computer. It is a contrived acronym for "Completely Automated Public Turing test to tell Computers and Humans Apart." 
    /// </summary>
    /// <remarks>
    /// On web validations, user-code must store an instance of Captcha in order to validate user provided challenge.
    /// </remarks>
    [Serializable]
    public class Captcha
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Captcha"/> class, creating a new access code. 
        /// </summary>
        /// <remarks></remarks>
        public Captcha()
        {
            DefineRamdomColorsAndFonts();
            _AccessCode = GenerateRamdomAccessCode();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Captcha"/> class, using a user-defined access code. 
        /// </summary>
        /// <param name="accessCode">A string with user-defined access code.</param>
        /// <remarks></remarks>
        public Captcha(string accessCode) 
        {
            DefineRamdomColorsAndFonts();
            _AccessCode = accessCode;
        }

        /// <summary>
        /// Creates a ramdom access code.
        /// </summary>
        private string GenerateRamdomAccessCode()
        {
            string code = "";
            Random rnd = new Random();
            for (int i = 0; i <= rnd.Next(4, 7); i++)
            {
                char strChar = (char)(rnd.Next(65, 90));
                code += strChar.ToString();
            }
            return code;
        }

        [NonSerialized]
        private Color[] bgColors;
        [NonSerialized]
        private Color[] fgColors;
        [NonSerialized]
        private string[] defaultFonts = null;

        private void DefineRamdomColorsAndFonts()
        {
            //setting ramdom default background colors.
            bgColors = new Color[] { Color.Violet, System.Drawing.Color.DarkBlue, System.Drawing.Color.DarkCyan, Color.DarkGoldenrod, System.Drawing.Color.IndianRed, System.Drawing.Color.Indigo };
            //setting ramdom default foregorund colors.
            fgColors = new Color[] { Color.White, Color.Aquamarine, System.Drawing.Color.Gold, System.Drawing.Color.LightGreen, Color.LightYellow, System.Drawing.Color.LightGoldenrodYellow };
            //setting ramdom default fonts
            defaultFonts = new string[] { "Arial", "Arial Black", "Tahoma", "Trebuchet MS", "Comic Sans MS", "Century Gothic" };
        }


        
        private const int ImageWidth = 220;
        private const int ImageHeight = 70;


        private string _AccessCode;
        /// <summary>
        /// Gets or sets a string with an access code that will be used on capcha algorithms. 
        /// If a null value is provided, a ramdom access code will be generated.
        /// </summary>
        public string AccessCode
        {
            get
            {
                return _AccessCode;
            }
            set
            {
                if (value == null)
                    _AccessCode = GenerateRamdomAccessCode();
                else
                    _AccessCode = value;
            }
        }


        /// <summary>
        /// Chooses a ramdom font to draw an image.
        /// </summary>
        /// <returns></returns>
        private Font GenerateRandomFont()
        {
            Random rnd = new Random();
            Font font = new Font(defaultFonts[rnd.Next(0, defaultFonts.Length)], rnd.Next(28, 32), FontStyle.Bold, GraphicsUnit.Point);

            return font;
        }

        private Brush GenerateRandomBackBrush()
        {
            Random rnd = new Random();
            return new SolidBrush(bgColors[rnd.Next(bgColors.Length)]);
        }

        private Pen GenerateRandomForePen()
        {
            return new Pen(GenerateRandomForeColor());
        }

        private Color GenerateRandomForeColor()
        {
            Random rnd = new Random();
            return fgColors[rnd.Next(fgColors.Length)];
        }



        /// <summary>
        /// Creates an image representation of the current access code.
        /// </summary>
        /// <returns>An JPEG image with the current representation of the access code.</returns>
        /// <remarks></remarks>
        public Image GenerateImage()
        {
            Random rnd = new Random();
            Font Font = GenerateRandomFont();
            SolidBrush brush = new SolidBrush(GenerateRandomForeColor());

            Bitmap bmp = new Bitmap(ImageWidth, ImageHeight);
            Graphics gr = Graphics.FromImage(bmp);

            //background:
            gr.FillRectangle(GenerateRandomBackBrush(), new Rectangle(0, 0, bmp.Width, bmp.Height));

            GraphicsPath pth = new GraphicsPath();
            pth.AddString(AccessCode, Font.FontFamily, System.Convert.ToInt32(Font.Style), Font.Size, new PointF(rnd.Next(60), rnd.Next(5, 10)), StringFormat.GenericTypographic);
            Matrix m = new Matrix();

            m.Rotate(rnd.Next(-4, 5));
            pth.Transform(m);


            gr.FillPath(brush, pth);
            gr.DrawPath(GenerateRandomForePen(), pth);

            gr.DrawLine(GenerateRandomForePen(), new Point(0, rnd.Next(bmp.Height)), new Point(bmp.Width, rnd.Next(bmp.Height)));
            gr.DrawLine(GenerateRandomForePen(), new Point(0, rnd.Next(bmp.Height)), new Point(bmp.Width, rnd.Next(bmp.Height)));
            gr.DrawLine(GenerateRandomForePen(), new Point(0, rnd.Next(bmp.Height)), new Point(bmp.Width, rnd.Next(bmp.Height)));

            for (int x = 0; x <= bmp.Width - 1; x++)
            {
                for (int y = 0; y <= bmp.Height - 1; y++)
                {
                    if (rnd.Next(4) == 1)
                    {
                        bmp.SetPixel(x, y, GenerateRandomForeColor());
                    }
                }
            }


            Font.Dispose();
            gr.Dispose();

            DistortImage(bmp, rnd.Next(5, 20) * System.Convert.ToInt32((rnd.Next(2) == 1) ? 1 : -1));

            return bmp;
        }


        /// <summary>Distorts the image.</summary>
        /// <param name="b">The image to be transformed.</param>
        /// <param name="distortion">An amount of distortion.</param>
        private void DistortImage(Bitmap b, double distortion)
        {

            int width = b.Width;
            int height = b.Height;

            //' Copy the image so that we're always using the original for source color
            Bitmap copy = (Bitmap)(b.Clone());
            // Iterate over every pixel
            for (int y = 0; y <= height - 1; y++)
            {

                for (int x = 0; x <= width - 1; x++)
                {

                    //' Adds a simple wave
                    int newX = x + (int)(distortion * Math.Sin(Math.PI * y / 64.0));
                    int newY = y + (int)(distortion * Math.Cos(Math.PI * x / 64.0));
                    if (newX < 0 || newX >= width)
                    {
                        newX = 0;
                    }
                    if (newY < 0 || newY >= height)
                    {
                        newY = 0;
                    }
                    b.SetPixel(x, y, copy.GetPixel(newX, newY));
                }
            }

        }


        /// <summary>
        /// Creates an audio representation of the current access code.
        /// </summary>
        /// <returns>A byte array of an PCM Wave audio form.</returns>
        /// <remarks></remarks>
        public byte[] GenerateAudio()
        {
            //TODO: Create a wave file without COM access to speech, or at least without referencing it.
            //throw new NotImplementedException();
            Random rnd = new Random();
            string toSpeak = string.Empty;
            foreach (char c in AccessCode.ToCharArray()) 
                toSpeak += c.ToString() + ".\r\n";

            string tempPath = Path.GetTempPath();

            if (!tempPath.EndsWith("\\")) tempPath += "\\";
            string tempFile = tempPath + "sound" + Guid.NewGuid().ToString() + ".wav";


            //usando o SpFileStream porque o memory stream nao da certo
            SpFileStream sound = null;
            try
            {
                sound = (SpFileStream)new SpFileStreamClass();
                sound.Open(tempFile, SpeechStreamFileMode.SSFMCreateForWrite);


                SpVoice speech = (SpVoice)new SpVoiceClass();
                ISpeechObjectTokens voices = speech.GetVoices();
                speech.Voice = voices.Item(rnd.Next(0, (int)voices.Count));
                //Dim format As New SpAudioFormat
                //format.Type = SpeechAudioFormatType.SAFTGSM610_11kHzMono
                //sound.Format = format

                speech.AudioOutputStream = sound;
                speech.Rate = -5;
                //de -10 a +10

                //speaks to the file
                speech.Speak(toSpeak, SpeechVoiceSpeakFlags.SVSFlagsAsync);
                speech.WaitUntilDone(-1);

                speech = null;
                voices = null;
            }
            catch (Exception ex)
            {
                try
                {
                    if (System.IO.File.Exists(tempFile))
                    {
                        System.IO.File.Delete(tempFile);
                    }
                }
                catch (Exception ex2)
                {
                }
                throw ex;
            }
            finally
            {
                try
                {
                    if (sound != null)
                        sound.Close();

                    sound = null;
                }
                catch (Exception ex)
                {
                }
            }

            if (System.IO.File.Exists(tempFile))
            {


                System.IO.FileStream mem = new System.IO.FileStream(tempFile, System.IO.FileMode.Open);

                byte[] bytes = new byte[(int)mem.Length + 1];
                int offset = 0;
                int remaining = (int)mem.Length;

                while (remaining > 0)
                {
                    int read = mem.Read(bytes, offset, remaining);
                    if (read <= 0) break; // TODO: might not be correct. Was : Exit Do

                    remaining -= read;
                    offset += read;
                }
                mem.Close();
                mem.Dispose();

                try
                {
                    System.IO.File.Delete(tempFile);
                }
                catch (Exception ex)
                {
                }
                return bytes;
            }
            else
            {
                return null;
            }

        }



        /// <summary>
        /// Validates the current challenge provided by a user.
        /// </summary>
        /// <param name="challenge">User-provided challange code.</param>
        /// <returns>True if user seems not to be a bot.</returns>
        public bool ValidateCaptcha(string challenge)
        {
            return string.Equals(this.AccessCode, challenge);
        }







        //Public Function TextToWav() As Byte()
        //    Dim rnd As New Random
        //    Dim b As Byte() = Nothing

        //    Try
        //        Dim spFlags As SpeechVoiceSpeakFlags = SpeechVoiceSpeakFlags.SVSFlagsAsync


        //        Dim speech As New SpVoice
        //        Dim voices As ISpeechObjectTokens = speech.GetVoices()
        //        speech.Voice = voices.Item(rnd.Next(voices.Count))

        //        Dim spMemoryStream As New SpMemoryStream
        //        spMemoryStream.Format.Type = SpeechAudioFormatType.SAFT11kHz8BitMono
        //        speech.AudioOutputStream = spMemoryStream

        //        Dim r As Integer = speech.Speak(AccessCode, spFlags)
        //        speech.WaitUntilDone(-1)


        //        spMemoryStream.Seek(0, SpeechStreamSeekPositionType.SSSPTRelativeToStart)
        //        b = CType(spMemoryStream.GetData(), Byte())
        //        Return b
        //    Catch ex As Exception
        //        Throw ex
        //    End Try

        //End Function

    }
}